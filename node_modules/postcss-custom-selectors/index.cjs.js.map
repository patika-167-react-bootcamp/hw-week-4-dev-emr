{"version":3,"file":"index.cjs.js","sources":["lib/selectors-ast-from-selectors-string.js","lib/custom-selectors-from-root.js","lib/transform-selectors-by-custom-selectors.js","lib/transform-rules.js","lib/import-from.js","lib/export-to.js","index.js"],"sourcesContent":["import parser from 'postcss-selector-parser';\n\n/* Return a Selectors AST from a Selectors String\n/* ========================================================================== */\n\nexport default selectorString => {\n\tlet selectorAST;\n\n\tparser(selectors => {\n\t\tselectorAST = selectors\n\t}).processSync(selectorString);\n\n\treturn selectorAST;\n};\n","import getASTFromSelectors from './selectors-ast-from-selectors-string';\n\n// return custom selectors from the css root, conditionally removing them\nexport default (root, opts) => {\n\t// initialize custom selectors\n\tconst customSelectors = {};\n\n\t// for each custom selector atrule that is a child of the css root\n\troot.nodes.slice().forEach(node => {\n\t\tif (isCustomSelector(node)) {\n\t\t\t// extract the name and selectors from the params of the custom selector\n\t\t\tconst [, name, selectors] = node.params.match(customSelectorParamsRegExp);\n\n\t\t\t// write the parsed selectors to the custom selector\n\t\t\tcustomSelectors[name] = getASTFromSelectors(selectors);\n\n\t\t\t// conditionally remove the custom selector atrule\n\t\t\tif (!Object(opts).preserve) {\n\t\t\t\tnode.remove();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn customSelectors;\n};\n\n// match the custom selector name\nconst customSelectorNameRegExp = /^custom-selector$/i;\n\n// match the custom selector params\nconst customSelectorParamsRegExp = /^(:--[A-z][\\w-]*)\\s+([\\W\\w]+)\\s*$/;\n\n// whether the atrule is a custom selector\nconst isCustomSelector = node => node.type === 'atrule' && customSelectorNameRegExp.test(node.name) && customSelectorParamsRegExp.test(node.params);\n","// return transformed selectors, replacing custom pseudo selectors with custom selectors\nexport default function transformSelectorList(selectorList, customSelectors) {\n\tlet index = selectorList.nodes.length - 1;\n\n\twhile (index >= 0) {\n\t\tconst transformedSelectors = transformSelector(selectorList.nodes[index], customSelectors);\n\n\t\tif (transformedSelectors.length) {\n\t\t\tselectorList.nodes.splice(index, 1, ...transformedSelectors);\n\t\t}\n\n\t\t--index;\n\t}\n\n\treturn selectorList;\n}\n\n// return custom pseudo selectors replaced with custom selectors\nfunction transformSelector(selector, customSelectors) {\n\tconst transpiledSelectors = [];\n\n\tfor (const index in selector.nodes) {\n\t\tconst { value, nodes } = selector.nodes[index];\n\n\t\tif (value in customSelectors) {\n\t\t\tfor (const replacementSelector of customSelectors[value].nodes) {\n\t\t\t\tconst selectorClone = selector.clone();\n\n\t\t\t\tselectorClone.nodes.splice(index, 1, ...replacementSelector.clone().nodes.map(node => {\n\t\t\t\t\t// use spacing from the current usage\n\t\t\t\t\tnode.spaces = { ...selector.nodes[index].spaces };\n\n\t\t\t\t\treturn node;\n\t\t\t\t}));\n\n\t\t\t\tconst retranspiledSelectors = transformSelector(selectorClone, customSelectors);\n\n\t\t\t\tadjustNodesBySelectorEnds(selectorClone.nodes, Number(index));\n\n\t\t\t\tif (retranspiledSelectors.length) {\n\t\t\t\t\ttranspiledSelectors.push(...retranspiledSelectors);\n\t\t\t\t} else {\n\t\t\t\t\ttranspiledSelectors.push(selectorClone);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn transpiledSelectors;\n\t\t} else if (nodes && nodes.length) {\n\t\t\ttransformSelectorList(selector.nodes[index], customSelectors);\n\t\t}\n\t}\n\n\treturn transpiledSelectors;\n}\n\n// match selectors by difficult-to-separate ends\nconst withoutSelectorStartMatch = /^(tag|universal)$/;\nconst withoutSelectorEndMatch = /^(class|id|pseudo|tag|universal)$/;\n\nconst isWithoutSelectorStart = node => withoutSelectorStartMatch.test(Object(node).type);\nconst isWithoutSelectorEnd = node => withoutSelectorEndMatch.test(Object(node).type);\n\n// adjust nodes by selector ends (so that .class:--h1 becomes h1.class rather than .classh1)\nconst adjustNodesBySelectorEnds = (nodes, index) => {\n\tif (index && isWithoutSelectorStart(nodes[index]) && isWithoutSelectorEnd(nodes[index - 1])) {\n\t\tlet safeIndex = index - 1;\n\n\t\twhile (safeIndex && isWithoutSelectorEnd(nodes[safeIndex])) {\n\t\t\t--safeIndex;\n\t\t}\n\n\t\tif (safeIndex < index) {\n\t\t\tconst node = nodes.splice(index, 1)[0];\n\n\t\t\tnodes.splice(safeIndex, 0, node);\n\n\t\t\tnodes[safeIndex].spaces.before = nodes[safeIndex + 1].spaces.before;\n\t\t\tnodes[safeIndex + 1].spaces.before = '';\n\n\t\t\tif (nodes[index]) {\n\t\t\t\tnodes[index].spaces.after = nodes[safeIndex].spaces.after;\n\t\t\t\tnodes[safeIndex].spaces.after = '';\n\t\t\t}\n\t\t}\n\t}\n};\n\n","import parser from 'postcss-selector-parser';\nimport transformSelectorsByCustomSelectors from './transform-selectors-by-custom-selectors';\n\n// transform custom pseudo selectors with custom selectors\nexport default (root, customSelectors, opts) => {\n\troot.walkRules(customPseudoRegExp, rule => {\n\t\tconst selector = parser(selectors => {\n\t\t\ttransformSelectorsByCustomSelectors(selectors, customSelectors, opts)\n\t\t}).processSync(rule.selector);\n\n\t\tif (opts.preserve) {\n\t\t\trule.cloneBefore({ selector });\n\t\t} else {\n\t\t\trule.selector = selector;\n\t\t}\n\t});\n};\n\nconst customPseudoRegExp = /:--[A-z][\\w-]*/;\n","import fs from 'fs';\nimport path from 'path';\nimport postcss from 'postcss';\nimport getSelectorsAstFromSelectorsString from './selectors-ast-from-selectors-string';\nimport getCustomSelectors from './custom-selectors-from-root';\n\n/* Import Custom Selectors from CSS AST\n/* ========================================================================== */\n\nfunction importCustomSelectorsFromCSSAST(root) {\n\treturn getCustomSelectors(root);\n}\n\n/* Import Custom Selectors from CSS File\n/* ========================================================================== */\n\nasync function importCustomSelectorsFromCSSFile(from) {\n\tconst css = await readFile(path.resolve(from));\n\tconst root = postcss.parse(css, { from: path.resolve(from) });\n\n\treturn importCustomSelectorsFromCSSAST(root);\n}\n\n/* Import Custom Selectors from Object\n/* ========================================================================== */\n\nfunction importCustomSelectorsFromObject(object) {\n\tconst customSelectors = Object.assign(\n\t\t{},\n\t\tObject(object).customSelectors || Object(object)['custom-selectors']\n\t);\n\n\tfor (const key in customSelectors) {\n\t\tcustomSelectors[key] = getSelectorsAstFromSelectorsString(customSelectors[key]);\n\t}\n\n\treturn customSelectors;\n}\n\n/* Import Custom Selectors from JSON file\n/* ========================================================================== */\n\nasync function importCustomSelectorsFromJSONFile(from) {\n\tconst object = await readJSON(path.resolve(from));\n\n\treturn importCustomSelectorsFromObject(object);\n}\n\n/* Import Custom Selectors from JS file\n/* ========================================================================== */\n\nasync function importCustomSelectorsFromJSFile(from) {\n\tconst object = await import(path.resolve(from));\n\n\treturn importCustomSelectorsFromObject(object);\n}\n\n/* Import Custom Selectors from Sources\n/* ========================================================================== */\n\nexport default function importCustomSelectorsFromSources(sources) {\n\treturn sources.map(source => {\n\t\tif (source instanceof Promise) {\n\t\t\treturn source;\n\t\t} else if (source instanceof Function) {\n\t\t\treturn source();\n\t\t}\n\n\t\t// read the source as an object\n\t\tconst opts = source === Object(source) ? source : { from: String(source) };\n\n\t\t// skip objects with custom selectors\n\t\tif (Object(opts).customSelectors || Object(opts)['custom-selectors']) {\n\t\t\treturn opts\n\t\t}\n\n\t\t// source pathname\n\t\tconst from = String(opts.from || '');\n\n\t\t// type of file being read from\n\t\tconst type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n\n\t\treturn { type, from };\n\t}).reduce(async (customSelectorsPromise, source) => {\n\t\tconst customSelectors = await customSelectorsPromise\n\t\tconst { type, from } = await source;\n\n\t\tif (type === 'ast') {\n\t\t\treturn Object.assign(customSelectors, importCustomSelectorsFromCSSAST(from));\n\t\t}\n\n\t\tif (type === 'css') {\n\t\t\treturn Object.assign(customSelectors, await importCustomSelectorsFromCSSFile(from));\n\t\t}\n\n\t\tif (type === 'js') {\n\t\t\treturn Object.assign(customSelectors, await importCustomSelectorsFromJSFile(from));\n\t\t}\n\n\t\tif (type === 'json') {\n\t\t\treturn Object.assign(customSelectors, await importCustomSelectorsFromJSONFile(from));\n\t\t}\n\n\t\treturn Object.assign(customSelectors, importCustomSelectorsFromObject(await source));\n\t}, Promise.resolve({}));\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst readFile = from => new Promise((resolve, reject) => {\n\tfs.readFile(from, 'utf8', (error, result) => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n});\n\nconst readJSON = async from => JSON.parse(await readFile(from));\n","import fs from 'fs';\nimport path from 'path';\n\n/* Import Custom Selectors from CSS File\n/* ========================================================================== */\n\nasync function exportCustomSelectorsToCssFile(to, customSelectors) {\n\tconst cssContent = Object.keys(customSelectors).reduce((cssLines, name) => {\n\t\tcssLines.push(`@custom-selector ${name} ${customSelectors[name]};`);\n\n\t\treturn cssLines;\n\t}, []).join('\\n');\n\tconst css = `${cssContent}\\n`;\n\n\tawait writeFile(to, css);\n}\n\n/* Import Custom Selectors from JSON file\n/* ========================================================================== */\n\nasync function exportCustomSelectorsToJsonFile(to, customSelectors) {\n\tconst jsonContent = JSON.stringify({\n\t\t'custom-selectors': customSelectors\n\t}, null, '  ');\n\tconst json = `${jsonContent}\\n`;\n\n\tawait writeFile(to, json);\n}\n\n/* Import Custom Selectors from Common JS file\n/* ========================================================================== */\n\nasync function exportCustomSelectorsToCjsFile(to, customSelectors) {\n\tconst jsContents = Object.keys(customSelectors).reduce((jsLines, name) => {\n\t\tjsLines.push(`\\t\\t'${escapeForJS(name)}': '${escapeForJS(customSelectors[name])}'`);\n\n\t\treturn jsLines;\n\t}, []).join(',\\n');\n\tconst js = `module.exports = {\\n\\tcustomSelectors: {\\n${jsContents}\\n\\t}\\n};\\n`;\n\n\tawait writeFile(to, js);\n}\n\n/* Import Custom Selectors from Module JS file\n/* ========================================================================== */\n\nasync function exportCustomSelectorsToMjsFile(to, customSelectors) {\n\tconst mjsContents = Object.keys(customSelectors).reduce((mjsLines, name) => {\n\t\tmjsLines.push(`\\t'${escapeForJS(name)}': '${escapeForJS(customSelectors[name])}'`);\n\n\t\treturn mjsLines;\n\t}, []).join(',\\n');\n\tconst mjs = `export const customSelectors = {\\n${mjsContents}\\n};\\n`;\n\n\tawait writeFile(to, mjs);\n}\n\n/* Export Custom Selectors to Destinations\n/* ========================================================================== */\n\nexport default function exportCustomSelectorsToDestinations(customSelectors, destinations) {\n\treturn Promise.all(destinations.map(async destination => {\n\t\tif (destination instanceof Function) {\n\t\t\tawait destination(defaultCustomSelectorsToJSON(customSelectors));\n\t\t} else {\n\t\t\t// read the destination as an object\n\t\t\tconst opts = destination === Object(destination) ? destination : { to: String(destination) };\n\n\t\t\t// transformer for custom selectors into a JSON-compatible object\n\t\t\tconst toJSON = opts.toJSON || defaultCustomSelectorsToJSON;\n\n\t\t\tif ('customSelectors' in opts) {\n\t\t\t\t// write directly to an object as customSelectors\n\t\t\t\topts.customSelectors = toJSON(customSelectors);\n\t\t\t} else if ('custom-selectors' in opts) {\n\t\t\t\t// write directly to an object as custom-selectors\n\t\t\t\topts['custom-selectors'] = toJSON(customSelectors);\n\t\t\t} else {\n\t\t\t\t// destination pathname\n\t\t\t\tconst to = String(opts.to || '');\n\n\t\t\t\t// type of file being written to\n\t\t\t\tconst type = (opts.type || path.extname(opts.to).slice(1)).toLowerCase();\n\n\t\t\t\t// transformed custom selectors\n\t\t\t\tconst customSelectorsJSON = toJSON(customSelectors);\n\n\t\t\t\tif (type === 'css') {\n\t\t\t\t\tawait exportCustomSelectorsToCssFile(to, customSelectorsJSON);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'js') {\n\t\t\t\t\tawait exportCustomSelectorsToCjsFile(to, customSelectorsJSON);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'json') {\n\t\t\t\t\tawait exportCustomSelectorsToJsonFile(to, customSelectorsJSON);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'mjs') {\n\t\t\t\t\tawait exportCustomSelectorsToMjsFile(to, customSelectorsJSON);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}));\n}\n\n/* Helper utilities\n/* ========================================================================== */\n\nconst defaultCustomSelectorsToJSON = customSelectors => {\n\treturn Object.keys(customSelectors).reduce((customSelectorsJSON, key) => {\n\t\tcustomSelectorsJSON[key] = String(customSelectors[key]);\n\n\t\treturn customSelectorsJSON;\n\t}, {});\n};\n\nconst writeFile = (to, text) => new Promise((resolve, reject) => {\n\tfs.writeFile(to, text, error => {\n\t\tif (error) {\n\t\t\treject(error);\n\t\t} else {\n\t\t\tresolve();\n\t\t}\n\t});\n});\n\nconst escapeForJS = string => string.replace(/\\\\([\\s\\S])|(')/g, '\\\\$1$2').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n","import getCustomSelectors from './lib/custom-selectors-from-root';\nimport transformRules from './lib/transform-rules';\nimport importCustomSelectorsFromSources from './lib/import-from';\nimport exportCustomSelectorsToDestinations from './lib/export-to';\n\nconst postcssCustomSelectors = (opts) => {\n\t// whether to preserve custom selectors and rules using them\n\tconst preserve = Boolean(Object(opts).preserve);\n\n\t// sources to import custom selectors from\n\tconst importFrom = [].concat